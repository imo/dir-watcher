// Generated by CoffeeScript 1.6.3
(function() {
  var existsSync, fs, getPath, inotify, inotifyFactory, isDirectorySync, isFileSync, path, unwatchDirectories, util, walkDirectoryTreeSync,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  inotifyFactory = require('inotify-plusplus');

  path = require('path');

  util = require('util');

  inotify = void 0;

  getPath = function(e) {
    return path.resolve(e.watch, e.name);
  };

  existsSync = (fs != null ? fs.existsSync : void 0) || (path != null ? path.existsSync : void 0);

  isDirectorySync = function(dir) {
    if (existsSync(dir)) {
      return fs.statSync(dir).isDirectory();
    } else {
      return false;
    }
  };

  isFileSync = function(file) {
    if (existsSync(file)) {
      return fs.statSync(file).isFile();
    } else {
      return false;
    }
  };

  unwatchDirectories = function(dir, watchedDirectories) {
    var dirTree, entry, _i, _len, _results;
    if (!isDirectorySync(dir)) {
      throw 'unwatchDirectories only accepts a directory as the first parameter.';
    }
    dirTree = walkDirectoryTreeSync(pathToUnwatch, true);
    _results = [];
    for (_i = 0, _len = dirTree.length; _i < _len; _i++) {
      entry = dirTree[_i];
      if (__indexOf.call(watchedDirectories, entry) >= 0) {
        watchedDirectories[entry]();
        _results.push(delete watchedDirectories[entry]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  walkDirectoryTreeSync = function(dir, directoriesOnly) {
    var addPathToList, pathList;
    if (directoriesOnly == null) {
      directoriesOnly = false;
    }
    if (!isDirectorySync(dir)) {
      throw 'walkDirectoryTreeSync only accepts a directory as the first parameter.';
    }
    pathList = [];
    addPathToList = function(entry) {
      var stat, subEntry, _i, _len, _ref, _results;
      if (existsSync(entry)) {
        if (directoriesOnly === false) {
          pathList.push(entry);
        }
        stat = fs.statSync(entry);
        if (stat.isDirectory()) {
          if (directoriesOnly === true) {
            pathList.push(entry);
          }
          _ref = fs.readdirSync(entry);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            subEntry = _ref[_i];
            _results.push(addPathToList(path.resolve(entry, subEntry)));
          }
          return _results;
        }
      }
    };
    addPathToList(path.resolve(dir));
    return pathList;
  };

  exports.rmRecursiveSync = function(dir) {
    var traverseDirToRemove;
    traverseDirToRemove = function(removePath) {
      var entry, entryPath, lstat, _i, _len, _ref, _results;
      _ref = fs.readdirSync(removePath);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        entryPath = path.resolve(removePath, entry);
        lstat = fs.lstatSync(entryPath);
        if (lstat.isFile() || lstat.isSymbolicLink()) {
          _results.push(fs.unlinkSync(entryPath));
        } else if (lstat.isDirectory()) {
          traverseDirToRemove(entryPath);
          _results.push(fs.rmdirSync(entryPath));
        } else {
          throw "rmRecursiveSync: Came across " + removePath + " while removing " + dir + " - it's neither a file, symlink or directory so I'm not sure what to do with it";
        }
      }
      return _results;
    };
    return traverseDirToRemove(path.resolve(dir));
  };

  exports.create = function(fileChangedCallback) {
    var addDirectoryToWatchList, watchedDirectories;
    watchedDirectories = [];
    addDirectoryToWatchList = function(dir) {
      var dirEntry, dirTree, _i, _len, _results;
      dirTree = walkDirectoryTreeSync(path.resolve(dir), true);
      _results = [];
      for (_i = 0, _len = dirTree.length; _i < _len; _i++) {
        dirEntry = dirTree[_i];
        if (__indexOf.call(watchedDirectories, dirEntry) < 0) {
          _results.push(watchedDirectories[dirEntry] = inotify.watch({
            close_write: function(e) {
              var entry;
              entry = getPath(e);
              return fileChangedCallback(entry);
            },
            create: function(e) {
              var entry;
              entry = getPath(e);
              if (isDirectorySync(entry)) {
                return addDirectoryToWatchList(entry);
              }
            },
            "delete": function(e) {
              var entry;
              entry = getPath(e);
              if (isDirectorySync(entry)) {
                return unwatchDirectories(entry, watchedDirectories);
              }
            },
            moved_from: function(e) {
              var entry;
              entry = getPath(e);
              if (isDirectorySync(entry)) {
                return unwatchDirectories(entry, watchedDirectories);
              }
            },
            moved_to: function(e) {
              var entry;
              entry = getPath(e);
              if (existsSync(entry)) {
                if (fs.statSync(entry).isDirectory()) {
                  return addDirectoryToWatchList(entry);
                } else {
                  return fileChangedCallback(entry);
                }
              }
            }
          }, dirEntry));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    return {
      get: function() {
        var key, value, _results;
        _results = [];
        for (key in watchedDirectories) {
          value = watchedDirectories[key];
          _results.push(key);
        }
        return _results;
      },
      watchDirectoryTreeSync: function(dir) {
        return addDirectoryToWatchList(dir);
      }
    };
  };

  exports.isDirectorySync = isDirectorySync;

  exports.isFileSync = isFileSync;

  exports.getMirrorPath = function(baseDirectoryPath, filePath, oldDirectoryName, newDirectoryName) {
    var oldPathPrefix, pathSuffix, startPos;
    oldPathPrefix = path.resolve(baseDirectoryPath, oldDirectoryName);
    startPos = oldPathPrefix.length;
    if (startPos > filePath.length) {
      throw 'getMirrorPath Error: baseDirectoryPath + oldDirectoryName should be shorter than filePath.';
    }
    if (filePath.slice(0, +(startPos - 1) + 1 || 9e9) !== oldPathPrefix) {
      throw 'getMirrorPath Error: The prefix of filePath should match baseDirectoryPath + oldDirectoryName.';
    }
    pathSuffix = filePath.slice(startPos + 1, +filePath.length + 1 || 9e9);
    return path.resolve(baseDirectoryPath, newDirectoryName, pathSuffix);
  };

  exports.getRelativePath = function(basePath, longPath) {
    if (basePath[basePath.length - 1] !== '/') {
      basePath += '/';
    }
    if (basePath.length > longPath.length) {
      throw 'getPathSuffix Error: basePath should be shorter than or equal to longPath.';
    }
    if (longPath.slice(0, +(basePath.length - 1) + 1 || 9e9) !== basePath) {
      throw 'getPathSuffix Error: The prefix of longPath should match basePath.';
    }
    return longPath.slice(basePath.length);
  };

  exports.setup = function(persist) {
    return inotify = inotifyFactory.create(persist);
  };

  exports.walkDirectoryTreeSync = walkDirectoryTreeSync;

}).call(this);
